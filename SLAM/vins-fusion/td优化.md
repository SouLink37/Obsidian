
## 速度求 td 优化过程

**目标**：求解相机与IMU的时间偏移 `td`

**已知**：
- `pts_i`, `pts_j`：特征点在帧i、帧j的归一化坐标
- `velocity_i`, `velocity_j`：特征点速度（前端计算好）
- 位姿、深度等其他优化变量

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  IMU真实时间:      t = 0.02s                                    │
│  相机记录的时间:   t_cam = 0.02s  (但实际拍摄时刻是 0.01s！)    │
│                                                                 │
│  真实位置:         ────────●──────────                          │
│                         (0.12) ← 这是真实位置                   │
│                                                                 │
│  相机观测到的:     ────────────●──────                          │
│                             (0.14) ← 这是相机看到的             │
│                                                                 │
│  问题：相机以为特征在 0.14，但实际在 0.12！                     │
│                                                                 │
│  补偿：pts_corrected = 0.14 - (td) * velocity                   │
│                      = 0.14 - (0.01) * 2.0                      │
│                      = 0.14 - 0.02                              │
│                      = 0.12  ✓ 得到正确位置                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```
**残差构建**：
```cpp
// 用 td 和 velocity 补偿观测点
pts_i_td = pts_i - (td - td_i) * velocity_i;
pts_j_td = pts_j - (td - td_j) * velocity_j;

// 重投影残差
residual = reproject(pts_i_td, depth, poses) - pts_j_td;
```

**优化**：
```
Ceres 迭代：
  → 当前 td 值 → 计算 pts_corrected → 计算残差 → 更新 td
  → 重复直到残差最小
```

**原理**：
- td 错了 → pts_corrected 错 → 重投影残差大
- td 对了 → pts_corrected 准 → 重投影残差小
- 优化器通过最小化残差自动找到正确的 td