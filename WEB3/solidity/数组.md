### 1.1 数组的分类

Solidity中的数组分为两大类：

**定长数组（Fixed-size Array）**：

```solidity
uint[5] public fixedArray;  // 长度固定为5
```

特点：

- 长度在声明时确定
- 长度永远不可改变
- 所有元素初始化为默认值（数字类型为0）
- 不能使用push或pop方法

**动态数组（Dynamic Array）**：

```solidity
uint[] public dynamicArray;  // 长度可变
```

特点：

- 长度可以动态改变
- 可以使用push添加元素
- 可以使用pop删除最后一个元素
- length是可变属性

### 1.3 数组类型对比

[](https://github.com/MetaNodeAcademy/solidity_lesson/blob/main/lesson3.1/Solidity%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91%20-%20%E6%95%B0%E7%BB%84\(%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99\).md#13-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E5%AF%B9%E6%AF%94)

|特性|定长数组|动态数组|
|---|---|---|
|声明语法|`uint[5]`|`uint[]`|
|初始化|`[1, 2, 3, 4, 5]`|`[1, 2, 3]`|
|长度|固定不变|可以改变|
|push方法|不支持|支持|
|pop方法|不支持|支持|
|length属性|常量|可变|
|Gas成本|相对较低|相对较高|
|使用场景|固定数量元素|动态数量元素|
### 1.4 删除

**delete操作总结**：

|操作|效果|length变化|注意事项|
|---|---|---|---|
|`delete arr[i]`|元素重置为0|不变|留下空洞|
|`delete arr`|清空数组|变为0|完全清空|
|`arr.pop()`|删除最后元素|减1|真正删除|
####  删除方法对比

在Solidity中，真正删除数组中间的元素需要特殊处理。有两种主要方法：

**方法1：保持顺序（移动元素）**

优点：保持元素的原有顺序 缺点：Gas消耗高（需要移动多个元素）

**方法2：快速删除（不保序）**

优点：Gas消耗低（只需两步操作） 缺点：不保持元素顺序

**何时使用哪种方法**：

|使用场景|推荐方法|原因|
|---|---|---|
|需要保持顺序（如排行榜）|保序删除|顺序重要|
|数组很小（<20个元素）|保序删除|Gas差异小|
|数组较大且顺序不重要|快速删除|节省Gas|
|用户列表、ID列表|快速删除|顺序无关紧要|
|历史记录、时间序列|保序删除|时间顺序重要|

### 1.5 solidity的二维数组声明和python c++行列相反， 访问和声明也相反


一个有 **2 行 3 列** 的整数数组：

- **C++**: `int matrix[2][3];`
    
- **Solidity**: `uint[3][2] matrix;`

|**操作**|**语法**|**含义**|
|---|---|---|
|**声明 (固定大小)**|`uint[列数][行数] name`|先写里面装什么，再写外面有多少个。|
|**访问 (读/写)**|`name[行索引][列索引]`|先进大盒子（行），再进小盒子（列）。|


###  全量替换数组（适用优化）

当需要更新数组中的大部分或全部元素时，memory优化可能有效：

```solidity
contract FullArrayUpdate {
    uint[] public data;
    
    // 未优化：循环中逐个更新
    function updateAllBad(uint[] calldata newData) external {
        require(newData.length == data.length, "Length mismatch");
        
        for(uint i = 0; i < data.length; i++) {
            data[i] = newData[i];  // 每次循环都写storage
        }
    }
    // Gas: 取决于数组长度
    // 问题：每个元素都要写storage
    
    // 优化：一次性替换整个数组
    function updateAllGood(uint[] calldata newData) external {
        require(newData.length == data.length, "Length mismatch");
        
        // 复制到memory
        uint[] memory temp = new uint[](newData.length);
        for(uint i = 0; i < newData.length; i++) {
            temp[i] = newData[i];
        }
        
        // 一次性替换
        data = temp;
    }
    // Gas: 可能更优（取决于数组大小和编译器优化）
    // 注意：需要实际测试验证
}
```