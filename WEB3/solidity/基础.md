## 0 准则
- 返回值如果是引用类型必须memory， 是值类型就什么都不加。
- 值类型不可以加存储位置修饰。
- memory数组不可以push，只能下标访问。
- mapping不能在函数内声明，只能全局声明。
- 函数内可以声明storage类型的引用
- 状态变量如果不显式声明访问修饰符，默认是 internal。函数必须显式声明访问修饰符，否则会编译报错。
- calldata只能用于 外部函数（external） 的参数。
## 1. 参考链接：
https://github.com/AmazingAng/WTF-Solidity
https://github.com/MetaNodeAcademy/solidity_lesson/tree/main

## 2. 可见性修饰符
## public，external，internal，private

| 修饰符      | 内部调用 | 外部调用 | 继承调用 | 用途    |
| -------- | ---- | ---- | ---- | ----- |
| public   | ✅ 可以 | ✅ 可以 | ✅ 可以 | 完全公开  |
| external | ❌ 不行 | ✅ 可以 | ✅ 可以 | 只给外部用 |
| internal | ✅ 可以 | ❌ 不行 | ✅ 可以 | 内部使用  |
| private  | ✅ 可以 | ❌ 不行 | ❌ 不行 | 严格私密  |

**public的特点**：

1. **外部可调用**：任何账户或合约都可以调用
2. **内部可调用**：合约内部可以直接调用
3. **继承可调用**：子合约可以调用和重写
4. **自动生成getter**：public状态变量自动创建getter函数

通常internal函数以下划线开头，如`_setValue`、`_calculateFee`，这是一种常见的命名约定。

**public 修饰状态变量 = 自动生成同名 getter 函数**


外部用户需要调用这个函数吗？
├─ 是 → 参数包含大数组或长字符串吗？
│       ├─ 是 → external（省gas）
│       └─ 否 → public
└─ 否 → 子合约需要访问吗？
        ├─ 是 → internal
        └─ 否 → private

## 3. 状态修饰符

状态修饰符定义了函数与区块链状态的交互方式。

| 修饰符     | 读取状态 | 修改状态 | 接收ETH | Gas消耗（外部调用） |
| ------- | ---- | ---- | ----- | ----------- |
| 默认      | 可以   | 可以   | 不可以   | 正常消耗        |
| view    | 可以   | 不可以  | 不可以   | 0（不改变状态）    |
| pure    | 不可以  | 不可以  | 不可以   | 0（不改变状态）    |
| payable | 可以   | 可以   | 可以    | 正常消耗        |
pure函数既不读取也不修改状态，只使用参数和局部变量。

**重要提示**：能用pure就pure，能用view就view！


- Interface 就是 Solidity 中的"虚函数"概念

## 4. 类比对比：

| 特性     | Interface | 虚函数      |
| ------ | --------- | -------- |
| 定义规范   | ✅ 只定义函数签名 | ✅ 定义虚函数  |
| 无具体实现  | ✅ 没有代码    | ✅ 没有代码   |
| 强制实现   | ✅ 继承者必须实现 | ✅ 子类必须重写 |
| 通过多态调用 | ✅ 可以      | ✅ 可以     |
|        |           |          |



## 5.int类型的选择

- 默认使用 `uint256`
- 需要负数时使用 `int256`
- 只有在变量打包优化时才考虑使用较小类型

## 6.除法

Solidity没有浮点数类型，所有除法运算都是整数除法

```
contract DivisionExample {
    function divide() public pure returns (uint) {
        uint result = 10 / 3;  // 结果是3，不是3.333...
        return result;
    }
    
    // 如果需要精度，需要使用定点数技巧
    function divideWithPrecision() public pure returns (uint) {
        uint numerator = 10 * 1000;  // 先乘以精度倍数
        uint denominator = 3;
        uint result = numerator / denominator;  // 3333
        // 实际值：3.333（需要在前端除以1000显示）
        return result;
    }
}
```

## 7.溢出

- 0.8.0版本开始，Solidity自动检查整数溢出
- 如果确定不会溢出，可以使用`unchecked`来节省gas

```
contract UncheckedExample {
    // 使用unchecked（谨慎使用！）
    function incrementUnchecked(uint x) public pure returns (uint) {
        unchecked {
            return x + 1;  // 不检查溢出，节省gas
        }
    }
    
    // 典型应用场景：循环计数器
    function sumArray(uint[] memory arr) public pure returns (uint) {
        uint sum = 0;
        for (uint i = 0; i < arr.length; ) {
            sum += arr[i];
            unchecked {
                i++;  // i不可能溢出，使用unchecked节省gas
            }
        }
        return sum;
    }
}
```

**何时使用unchecked**：

- 循环计数器（数组长度不可能达到uint256上限）
- 已经检查过不会溢出的计算
- 性能关键路径（需要节省gas）

## 8.地址类型

###  8.1 地址类型基础

地址类型（`address`）是Solidity特有的类型，用于存储以太坊地址。一个地址是20字节（160位）的值。

**两种地址类型**：

```solidity
contract AddressTypes {
    // 普通地址
    address public normalAddress;
    
    // 可支付地址
    address payable public payableAddress;
}
```

**两种地址的区别**：

| 特性         | address     | address payable |
| ---------- | ----------- | --------------- |
| 接收ETH      | 不可以         | 可以              |
| transfer方法 | 没有          | 有               |
| send方法     | 没有          | 有               |
| 余额查询       | 可以          | 可以              |
| 隐式转换       | 不能转为payable | 可以转为普通address   |
- 0.8.0 之后 `msg.sender` 默认为不可支付
### 8.2 地址类型常用功能

```
contract AddressFeatures {
    // 查询地址余额
    function getBalance(address addr) public view returns (uint) {
        return addr.balance;  // 返回该地址的ETH余额（单位：wei）
    }
    
    // 获取当前合约地址
    function getContractAddress() public view returns (address) {
        return address(this);
    }
    
    // 获取合约余额
    function getContractBalance() public view returns (uint) {
        return address(this).balance;
    }
    
    // 检查是否为零地址
    function isZeroAddress(address addr) public pure returns (bool) {
        return addr == address(0);
        // address(0) = 0x0000000000000000000000000000000000000000
    }
}
```

### 8.3 特殊地址变量


Solidity提供了一些特殊的全局地址变量：

```solidity
contract SpecialAddresses {
    function getSpecialAddresses() public view returns (address, address, address) {
        return (
            msg.sender,      // 当前调用者的地址
            tx.origin,       // 交易发起者的地址（最原始的调用者）
            address(this)    // 当前合约的地址
        );
    }
    
    // msg.sender vs tx.origin的区别
    function demonstrateDifference() public view returns (string memory) {
        // 用户 -> 合约A -> 合约B
        // 在合约B中：
        // msg.sender = 合约A的地址
        // tx.origin = 用户的地址
        
        if (msg.sender == tx.origin) {
            return "Called directly by user";
        } else {
            return "Called by another contract";
        }
    }
}
```

**重要安全提示**：不要使用`tx.origin`进行权限验证，因为它容易受到钓鱼攻击！始终使用`msg.sender`。

### 8.4 转账功能

`address payable`类型支持转账功能：

```solidity
contract TransferExample {
    // 接收ETH的函数需要payable修饰符
    receive() external payable {}
    
    // transfer方法（推荐，失败会回退）
    function transferETH(address payable recipient, uint amount) public {
        recipient.transfer(amount);  // 如果失败，整个交易回退
    }
    
    // send方法（不推荐，需要检查返回值）
    function sendETH(address payable recipient, uint amount) public returns (bool) {
        bool success = recipient.send(amount);  // 失败返回false，不回退
        require(success, "Send failed");
        return success;
    }
    
    // call方法（最灵活，推荐用于转账）
    function callTransfer(address payable recipient, uint amount) public {
        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Transfer failed");
    }
}
```

**三种转账方法的对比**：

|方法|Gas限制|失败处理|推荐程度|
|---|---|---|---|
|transfer|2300 gas|自动回退|中等|
|send|2300 gas|返回false|低|
|call|无限制|返回false|高（配合require）|
## 9 运算符

### 9.1 位运算符

位运算符直接操作整数的二进制位：

```solidity
contract BitwiseOperators {
    function bitwise() public pure returns (uint, uint, uint, uint, uint, uint) {
        uint a = 5;   // 二进制：0101
        uint b = 3;   // 二进制：0011
        
        return (
            a & b,   // 按位与：1（0001）
            a | b,   // 按位或：7（0111）
            a ^ b,   // 按位异或：6（0110）
            ~a,      // 按位非：uint256最大值-5
            a << 1,  // 左移：10（1010）
            a >> 1   // 右移：2（0010）
        );
    }
    
    // 位运算的实际应用
    function checkBit(uint value, uint position) public pure returns (bool) {
        // 检查某一位是否为1
        return (value & (1 << position)) != 0;
    }
    
    function setBit(uint value, uint position) public pure returns (uint) {
        // 将某一位设置为1
        return value | (1 << position);
    }
    
    function clearBit(uint value, uint position) public pure returns (uint) {
        // 将某一位设置为0
        return value & ~(1 << position);
    }
}
```

### 9.2 短路运算


逻辑与（`&&`）和逻辑或（`||`）支持短路运算：

```solidity
contract ShortCircuit {
    // 逻辑与的短路
    function andShortCircuit(uint x, uint y) public pure returns (bool) {
        // 如果x == 0，不会执行y / x（避免除零错误）
        if (x != 0 && y / x > 5) {
            return true;
        }
        return false;
    }
    
    // 逻辑或的短路
    function orShortCircuit(bool condition1, bool condition2) public pure returns (bool) {
        // 如果condition1是true，不会检查condition2
        return condition1 || condition2;
    }
    
    // 短路运算的实际应用
    function safeTransfer(address recipient, uint amount) public view returns (bool) {
        // 先检查简单条件，再检查复杂条件（优化gas）
        return recipient != address(0) && amount > 0 && address(this).balance >= amount;
    }
}
```

**短路运算的优势**：

1. **防止错误**：避免除零、数组越界等错误
2. **优化gas**：避免不必要的计算
3. **逻辑清晰**：先检查简单条件


## 10 类型转换

**隐式转换规则**：

- 小整数类型可以隐式转换为大整数类型
- 无符号整数不能隐式转换为有符号整数
- 有符号整数不能隐式转换为无符号整数
### 10.1 安全的类型转换


在进行显式转换时，应该先检查范围：

```solidity
contract SafeConversion {
    // 安全转换函数
    function safeConvertToUint8(uint256 value) public pure returns (uint8) {
        require(value <= type(uint8).max, "Value too large for uint8");
        return uint8(value);
    }
    
    function safeConvertToUint16(uint256 value) public pure returns (uint16) {
        require(value <= type(uint16).max, "Value too large for uint16");
        return uint16(value);
    }
    
    // 使用type(T).max和type(T).min
    function getTypeInfo() public pure returns (uint8, uint8, int8, int8) {
        return (
            type(uint8).max,   // 255
            type(uint8).min,   // 0
            type(int8).max,    // 127
            type(int8).min     // -128
        );
    }
}
```

**type(T).max和type(T).min**：

```solidity
contract TypeInfo {
    function showTypeInfo() public pure returns (
        uint8, uint8,
        uint16, uint16,
        uint256, uint256,
        int8, int8,
        int256, int256
    ) {
        return (
            type(uint8).min,    // 0
            type(uint8).max,    // 255
            type(uint16).min,   // 0
            type(uint16).max,   // 65535
            type(uint256).min,  // 0
            type(uint256).max,  // 2^256-1
            type(int8).min,     // -128
            type(int8).max,     // 127
            type(int256).min,   // -2^255
            type(int256).max    // 2^255-1
        );
    }
}
```


### 11 函数重载

**可以重载**：
- 参数数量不同
- 参数类型不同
- 参数顺序不同

**不能重载**：
- 只有返回值不同
- 只有modifier不同
- 只有可见性不同
### 12 命名规范

```solidity
contract NamingConventions {
    // 内部函数：下划线开头
    function _internalHelper() internal {}
    
    // 私有函数：下划线开头
    function _privateHelper() private {}
    
    // Public/External：正常命名
    function publicFunction() public {}
    function externalFunction() external {}
    
    // Modifier：描述性命名
    modifier onlyOwner() { _; }
    modifier whenNotPaused() { _; }
    modifier validAddress(address addr) { _; }
}
```

## 13 **receive和fallback**：

```solidity
contract SpecialPayable {
    event Received(address sender, uint256 amount);
    event Fallback(address sender, uint256 amount, bytes data);
    
    // receive：接收纯ETH转账（无data）
    receive() external payable {
        emit Received(msg.sender, msg.value);
    }
    
    // fallback：调用不存在的函数或带data的转账
    fallback() external payable {
        emit Fallback(msg.sender, msg.value, msg.data);
    }
}
```


- **msg.data 为空**
    
    - 有 `receive() external payable` → 调 `receive`
        
    - 否则如果有 `fallback() external payable` → 调 `fallback`
        
    - 否则 → **revert**
        
- **msg.data 不为空**
    
    - 如果 data 能匹配到某个函数 → 调那个函数（要带 ETH 则该函数必须 `payable`）
        
    - 否则如果有 `fallback() external payable` → 调 `fallback`
        
    - 否则 → **revert**

## 14 循环中应该注意

| 方法        | Gas消耗 | 适用场景       | 推荐度  |
| --------- | ----- | ---------- | ---- |
| 无限制循环     | 极高    | 危险，避免      | 不推荐  |
| 限制循环次数    | 中等    | 小数据集(<100) | 推荐   |
| mapping查询 | 恒定(低) | 单个查询       | 强烈推荐 |
| 分批处理      | 分散    | 大数据集       | 推荐   |
| 链下计算      | 几乎为0  | 复杂计算       | 强烈推荐 |


## 15 require && assert

### 15.1 require**典型使用场景**：

```solidity
contract RequireUseCases {
    address public owner;
    bool public paused;
    
    constructor() {
        owner = msg.sender;
    }
    
    // 场景1：权限检查
    function ownerOnly() public view {
        require(msg.sender == owner, "Not the owner");
        // 操作...
    }
    
    // 场景2：状态检查
    function whenNotPaused() public view {
        require(!paused, "Contract is paused");
        // 操作...
    }
    
    // 场景3：参数验证
    function setAge(uint age) public pure {
        require(age > 0 && age < 150, "Invalid age");
        // 设置年龄...
    }
    
    // 场景4：余额检查
    function withdraw(uint amount) public view {
        require(address(this).balance >= amount, "Insufficient contract balance");
        // 提款...
    }
    
    // 场景5：时间条件
    function afterDeadline(uint deadline) public view {
        require(block.timestamp >= deadline, "Too early");
        // 操作...
    }
}
```

### 15.2 assert - 内部检查

assert用于检查不应该失败的条件，主要用于检测代码bug和不变量。

**语法**：

```solidity
assert(条件);
```

**条件为false时**：

- 交易回滚
- 表示代码有bug
- 返还剩余Gas（Solidity 0.8.0+）
- 不支持错误消息

**示例**：

```solidity
contract AssertExample {
    mapping(address => uint) public balances;
    uint public totalSupply;
    
    function transfer(address to, uint amount) public {
        // require：验证外部输入
        require(to != address(0), "Invalid address");
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        // 记录转账前，两个账户的余额总和
        uint balanceSumBefore = balances[msg.sender] + balances[to];
        
        // 执行转账
        balances[msg.sender] -= amount;
        balances[to] += amount;
        
        // assert：检查不变量
        // 逻辑上：转账后，两个账户的余额总和必须与转账前完全一致
        assert(balances[msg.sender] + balances[to] == balanceSumBefore);
        // 如果这个检查失败，说明余额计算逻辑出现了极其严重的 Bug（如溢出或赋值错误）
    }
    
    function mint(address to, uint amount) public {
        require(to != address(0), "Invalid address");
        
        uint supplyBefore = totalSupply;
        
        balances[to] += amount;
        totalSupply += amount;
        
        // 检查不变量：新的总供应 = 旧的 + 增发的
        assert(totalSupply == supplyBefore + amount);
    }
}
```


### 15.3 **require vs assert对比**：

|特性|require|assert|
|---|---|---|
|用途|外部验证|内部检查|
|失败原因|用户错误/外部条件|代码bug|
|错误消息|支持|不支持|
|Gas返还|是|是（0.8.0+）|
|使用频率|非常高（90%）|很低（10%）|

**使用原则**：

- **require**：验证用户输入、检查外部条件
- **assert**：检查代码逻辑、验证不变量

大多数情况下使用require，只在需要检查不变量时使用assert。


### 15.4 revert - 灵活的错误处理

revert提供了更灵活的错误处理方式。

**基础用法**：

```solidity
contract RevertExample {
    mapping(address => uint) public balances;
    
    function complexCheck(address to, uint amount) public {
        // 方式1：带字符串消息
        if (to == address(0)) {
            revert("Invalid address");
        }
        
        if (amount == 0) {
            revert("Amount cannot be zero");
        }
        
        if (balances[msg.sender] < amount) {
            revert("Insufficient balance");
        }
        
        // 执行转账
        balances[msg.sender] -= amount;
        balances[to] += amount;
    }
}
```

**自定义错误（Solidity 0.8.4+）**：

```solidity
contract CustomErrors {
    // 定义自定义错误
    error InsufficientBalance(uint requested, uint available);
    error InvalidAddress(address addr);
    error AmountTooLow(uint amount, uint minimum);
    error Unauthorized(address caller);
    
    mapping(address => uint) public balances;
    address public owner;
    uint public constant MIN_AMOUNT = 100;
    
    constructor() {
        owner = msg.sender;
    }
    
    function transfer(address to, uint amount) public {
        // 使用自定义错误
        if (to == address(0)) {
            revert InvalidAddress(to);
        }
        
        if (amount < MIN_AMOUNT) {
            revert AmountTooLow(amount, MIN_AMOUNT);
        }
        
        if (balances[msg.sender] < amount) {
            revert InsufficientBalance({
                requested: amount,
                available: balances[msg.sender]
            });
        }
        
        balances[msg.sender] -= amount;
        balances[to] += amount;
    }
    
    function adminFunction() public {
        if (msg.sender != owner) {
            revert Unauthorized(msg.sender);
        }
        // 管理员操作
    }
}
```

**自定义错误的优势**：

|特性|字符串错误|自定义错误|
|---|---|---|
|Gas成本|高|低（节省约50%）|
|可带参数|否|是|
|类型安全|否|是|
|易于解析|难|易|
|前端集成|复杂|简单|


### 15.5 错误处理对比

|特性|require|assert|revert|
|---|---|---|---|
|用途|输入验证|内部检查|灵活控制|
|条件判断|需要|需要|不需要|
|错误消息|支持|不支持|支持|
|自定义错误|支持|不支持|支持|
|Gas返还|是|是|是|
|使用频率|很高|低|中等|

**选择指南**：

```
需要错误处理？
    ↓
简单条件判断？
    ├─ 是 → require
    └─ 否 → 复杂逻辑？
            ├─ 是 → revert
            └─ 否 → 检查不变量？
                    └─ 是 → assert
```

## 16 status machine  状态机

**状态转换图**：


```
┌───────────┐
│ Preparing │────────────────────────┐
└─────┬─────┘                        │
      │ start()                      │
      v                              │   cancel()    ┌───────────┐
┌───────────────────────┐            │─────────────▶ │ Cancelled │
│      Active           │            │               └───────────┘
│                       │            │     
│   contribute()        │            │
│   ┌───────────────┐   │────────────┘
│   │               │   │
│   └───────▶ (self)┘   │
└─────┬─────────────────┘
      │ check()
      v
┌───────────┐
│ Checking  │
└─────┬─────┘
      │ finalize()
      ├──────────────▶ ┌─────────┐
      │                │ Success │
      │                └─────────┘
      └──────────────▶ ┌─────────┐
                       │ Failed  │
                       └─────────┘

```

## 17 安全编程原则

**Checks-Effects-Interactions模式**

这是智能合约开发中最重要的安全模式。

```solidity
contract CEIPattern {
    mapping(address => uint) public balances;
    
    // 正确：遵循CEI模式
    function withdraw(uint amount) public {
        // 1. Checks - 检查
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        // 2. Effects - 更新状态
        balances[msg.sender] -= amount;
        
        // 3. Interactions - 外部调用
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
    }
    
    // 错误：先外部调用，后更新状态（重入攻击风险）
    function dangerousWithdraw(uint amount) public {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        // 危险：先外部调用
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
        
        // 后更新状态（可能被重入攻击）
        balances[msg.sender] -= amount;
    }
}
```

**为什么CEI模式重要？**

重入攻击示例：

```solidity
// 受害合约（有漏洞）
contract Vulnerable {
    mapping(address => uint) public balances;
    
    function withdraw() public {
        uint amount = balances[msg.sender];
        
        // 危险：先转账
        msg.sender.call{value: amount}("");
        
        // 后更新余额
        balances[msg.sender] = 0;
    }
}

// 攻击合约
contract Attacker {
    Vulnerable public victim;
    
    fallback() external payable {
        // 在收到钱后，再次调用withdraw
        // 因为余额还没更新，可以重复提取
        if (address(victim).balance > 0) {
            victim.withdraw();  // 重入攻击！
        }
    }
}
```

## 18 抽象合约， 接口
|特性|合约|抽象合约|接口|
|---|---|---|---|
|关键字|contract|abstract contract|interface|
|函数实现|必须全部实现|可以部分实现|不能有实现|
|函数可见性|任意|任意|必须external|
|状态变量|允许|允许|不允许|
|构造函数|允许|允许|不允许|
|可部署|是|否|否|

ERC20是最经典的接口定义示例。

```solidity
interface IERC20 {
    // 查询函数
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function allowance(address owner, address spender) 
        external view returns (uint256);
    
    // 操作函数
    function transfer(address to, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
    
    // 事件
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}
```