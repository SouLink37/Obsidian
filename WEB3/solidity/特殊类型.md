# 1 address
### 1.1 address类型概述

address是Solidity特有的20字节类型，用于存储以太坊地址（160位）。

**地址格式**：

```solidity
0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb1
```

### 1.2 address vs address payable

Solidity提供了两种address类型，它们有重要区别。

**基本对比**：

|特性|address|address payable|
|---|---|---|
|存储任何地址|支持|支持|
|查询余额(.balance)|支持|支持|
|查询代码(.code)|支持|支持|
|接收以太币|不支持|支持|
|transfer方法|不支持|支持|
|send方法|不支持|支持|
|call方法|支持|支持|
### 1.3 transfer
| 方法       | gas限制 | 失败处理    | 推荐度 | 使用场景              |
| -------- | ----- | ------- | --- | ----------------- |
| transfer | 2300  | 自动回滚    | 中等  | 简单转账              |
| send     | 2300  | 返回false | 低   | 不推荐               |
| call     | 无限制   | 返回false | 高   | 配合ReentrancyGuard |

2024年后推荐使用：**call + ReentrancyGuard**

```solidity
contract RecommendedPattern {
    bool private locked;
    
    modifier noReentrant() {
        require(!locked, "Reentrant call");
        locked = true;
        _;
        locked = false;
    }
    
    function withdraw(uint amount) public noReentrant {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        // Effects
        balances[msg.sender] -= amount;
        
        // Interactions
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
    }
}
```

**CEI模式（Checks-Effects-Interactions）**

这是智能合约安全的黄金法则！

```solidity
function withdraw(uint amount) public {
    // 1. Checks - 检查所有条件
    require(balances[msg.sender] >= amount, "Insufficient balance");
    require(amount > 0, "Amount must be positive");
    
    // 2. Effects - 更新状态变量
    balances[msg.sender] -= amount;
    
    // 3. Interactions - 调用外部合约/转账
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success, "Transfer failed");
}
```

## 2 全局变量

全局变量是Solidity内置的特殊变量，提供区块链、交易、调用的信息。

**三大类别**：

**msg对象 - 消息/调用信息**：

- `msg.sender`：调用者地址（最常用）
- `msg.value`：发送的ETH数量（最常用）
- `msg.data`：完整调用数据
- `msg.sig`：函数选择器

**block对象 - 区块信息**：

- `block.timestamp`：当前区块时间戳（常用）
- `block.number`：当前区块号（常用）
- `block.gaslimit`：区块gas限制
- `block.coinbase`：矿工/验证者地址
- `blockhash(n)`：获取区块哈希

**tx对象 - 交易信息**：

- `tx.origin`：交易发起者（危险，不要用于权限检查）
- `tx.gasprice`：交易gas价格

**其他重要函数**：

- `gasleft()`：剩余gas
- `keccak256()`：哈希函数
- `abi.encode()`：编码函数


### 2.1 tx.origin - 危险，不要用

**tx.origin的唯一合法用途**：

检查调用链中是否包含EOA（很少使用）

```solidity
function isOriginEOA() public view returns (bool) {
    return tx.origin == msg.sender;
    // true：直接由EOA调用
    // false：通过合约调用
}
```

**安全原则**：

永远不要使用tx.origin进行权限验证！


## 3. constant和immutable

### 3.1**constant的特点**：

1. **编译时确定**：值必须是常量表达式
2. **内联替换**：编译器将常量直接替换到代码中
3. **不占storage**：不消耗storage槽位
4. **访问cost = 0**：相当于直接使用数字
5. **不可修改**：运行时绝对不能改变

```
contract ConstantRules {
    // 可以：字面值
    uint public constant NUMBER = 100;
    
    // 可以：计算表达式
    uint public constant RESULT = 50 * 2;
    
    // 可以：使用其他常量
    uint public constant BASE = 10;
    uint public constant DERIVED = BASE * 10;
    
    // 不可以：运行时值
    // uint public constant TIME = block.timestamp;  // 编译错误
    // uint public constant SENDER = uint160(msg.sender);  // 编译错误
    
    // 不可以：在构造函数中赋值
    // uint public constant VALUE;
    // constructor() {
    //     VALUE = 100;  // 编译错误
    // }
}
```

### 3.2 immutable - 部署时常量

**定义**：

immutable可以在构造函数中赋值，一旦部署后就不能改变。

**语法**：

```solidity
类型 public immutable 变量名;
```

**示例**：

```solidity
contract ImmutableExample {
    // immutable变量
    address public immutable OWNER;
    address public immutable FACTORY;
    uint public immutable DEPLOYED_AT;
    uint public immutable INITIAL_SUPPLY;
    
    // 在构造函数中赋值
    constructor(address factory, uint supply) {
        OWNER = msg.sender;
        FACTORY = factory;
        DEPLOYED_AT = block.timestamp;
        INITIAL_SUPPLY = supply;
    }
    
    // 使用immutable
    function checkOwner() public view returns (bool) {
        return msg.sender == OWNER;
        // 访问immutable比storage便宜，约200 gas
    }
}
```

**immutable的特点**：

1. **部署时确定**：在构造函数中赋值
2. **运行时不可变**：部署后不能修改
3. **不占storage**：存储在合约代码中
4. **访问便宜**：约200 gas（比storage的2100便宜）
5. **可用运行时值**：可以使用msg.sender、block.timestamp等

### 3.3 三种变量类型对比

|特性|storage变量|constant|immutable|
|---|---|---|---|
|赋值时机|任何时候|编译时|构造函数|
|可修改性|可修改|不可修改|不可修改|
|存储位置|Storage|代码（内联）|代码|
|访问成本|~2100 gas|0 gas|~200 gas|
|可用运行时值|是|否|是|
|典型用途|动态数据|固定常量|部署时确定的值|